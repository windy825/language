## Time Complexity



안녕하세요! 문제 열심히 푸시고 계신가요??

파이썬 wiki 에 있는 자료들을 모아 왔습니다.

실행시간과 복잡도에 대해 궁금했던 여러 operation 들을 한번 훑어 볼게요.



지금 우리가 사용하는 CPython에서

여러 자료구조 및 컨테이너와 관련된 operation들을  `Big-O` 표기로 살펴 보겠습니다.

낮은 버전이라 할지라도 지금 것 보다 `O(*log*n)` 이상으로 느려지진 않습니다. 





#### 공통 참고

- **n** = 현재 있는 컨테이너의 원소 개수
- **k** = parameter (operation이 사용하는 매개변수) 또는 parameter에 담긴 원소의 개수
- **Average case** 는 매개변수를 무작위로 균일하게 생성해서 테스트, (평균적인 값이라고 보면 됨)





#### LIST

|    Operation     | Average Case |                무슨 기능??                 |
| :--------------: | :----------: | :----------------------------------------: |
|       copy       |     O(n)     | 1차원 리스트 복사 (arr2 = arr1[:] 같은 거) |
|     append()     |     O(1)     |            리스트 끝에 값 추가             |
|      pop()       |     O(1)     |          마지막 원소 반환 및 제거          |
| pop intermediate |     O(n)     |               설명 밑에 있음               |
|     insert()     |     O(n)     |             특정위치에 값 삽입             |
|      get()       |     O(1)     |                특정 값 반환                |
|     set Item     |     O(1)     |               특정 값을 변경               |
|   delete Item    |     O(n)     |                특정 값 삭제                |
|    iteration     |     O(n)     |                    순회                    |
|   get [Slice]    |     O(k)     |       특정 슬라이스(원소가 k개) 반환       |
|   del [Slice]    |     O(n)     |          특정 부분 슬라이스 삭제           |
|   set [Slice]    |    O(k+n)    |          특정 부분 슬라이스 변경           |
|     extend()     |     O(k)     |   리스트 끝에 컨테이너(원소가 k개) 추가    |
|      sort()      |  O(n log n)  |               오름차순 정렬                |
|     multiply     |    O(nk)     |             리스트에 k 곱하기              |
|    x in list     |     O(n)     |    x값이 있는지 확인 후 True/False 반환    |
|   min(), max()   |     O(n)     |              최소, 최대 반환               |
|      len()       |     O(1)     |                 길이 반환                  |

- 중요한 점은 **원본 배열을 재정렬하는 시간이 포함**된다는 것 입니다.

  예를 들면 특정 원소를 del을 통해 없앤다고 생각해볼게요, 

  그러면 없앤 지점은 뻥 뚫린 상태가 되있습니다. 그럼 그 뚫린지점에서 뒤의 배열들을

  del 시킨 수만큼 앞으로 땡겨줘야 겠죠? 그래서 한 원소만 삭제한다 하더라도, 삭제된 지점

  이후의 데이터들을 다시 앞으로 하나씩 땡겨줘야 하기 때문에 데이터 갯수 n 만큼 걸린다고 평군

  적인 값이 나오게 됩니다.

  (del 을 뒷부분에 하면 당연히 재정렬 시간이 덜 걸리겠죠? 하지만 표시된 복잡도는  여러 위치에서

  의 del을 한 후 각각의 **시간 복잡도를 평균을 내었기 때문에 n의 복잡도**를 가진답니다.) 

- pop intermediate

  크기가 n인 목록에서 인덱스 k에 있는 중간 요소를 `pop` 하게 되면 k 이후의 모든 요소가 하나씩 왼쪽으로 이동해야 합니다.

  (위의 내용을 생각하면 이해가 쉬울 거에요)

  간단하게 생각해보면 **n - k** 만큼의 요소를 이동해야 하므로 작업은 O(n-k) 가 걸릴겁니다.

  그러나 표시된 복잡도는 **평균값**이란 거! 잊지 마세요





#### SET	

(s 와 t 는 특정 집합입니다.)

|           **Operation**           |     **Average case**      |              **Worst Case** (최악의 경우)              |
| :-------------------------------: | :-----------------------: | :----------------------------------------------------: |
|              x in s               |           O(1)            |                          O(n)                          |
|          s \| t (합집합)          |  O(  len(s) + len(t)  )   |                           -                            |
|          s & t  (교집합)          | O(  min(len(s), len(t)  ) |                 O(  len(s) * len(t)  )                 |
| s1 & s2 & .. & sn  (교집합 n-1번) |             -             | (n-1)*O(l)    *where l is max( len(s1) ,.., len(sn) )* |
|          s - t (차집합)           |         O(len(s))         |                                                        |

- 교집합 n-1번 하는 연산의 최악의 경우는 **가장 많은 원소를 가진 집합이 n개**일때 : (n-1) * (max집합의 원소 갯수) 





#### DICT

| **Operation** | **Average Case** | **Worst Case** |
| :-----------: | :--------------: | :------------: |
|    k in d     |       O(1)       |      O(n)      |
|     Copy      |       O(n)       |      O(n)      |
|   Get Item    |       O(1)       |      O(n)      |
|   Set Item    |       O(1)       |      O(n)      |
|  Delete Item  |       O(1)       |      O(n)      |
|   Iteration   |       O(n)       |      O(n)      |

여기서 case에 이용된 예들은 모두 **해쉬가  충돌되지 않게 설정된 값은 아닙니다만, 그렇다고 너무 자주 충돌하는 사례들이 포함된 것은 아닙니다. **

**그냥 평균적인 값으로만 봐주세요**

 hash 개념은 궁금하신 분은 따로 공부해보세요! 나중에 알아볼게요, 지금은 다른 할게 많아요.