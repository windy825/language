### QUEUE





- **삽입, 삭제의 위치가 제한적인 자료구조**

  - 활용 : 버퍼

    데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역

    버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미

    일반적으로 입출력및 네트워크와 관련된 기능에서 이용

    순서대로 입력 - 출력 - 전달 이 이루어져야 하므로 fifo방식의 자료구조인 큐 가 활용됨.

  - 예시 : 키보드 버퍼


​     

   

- **선입선출 구조 (FIFO : first in first out)**
  - Front : 저장된 원소 중 첫 번째 원소
  - Rear : 저장된 원소 중 마지막 번째 원소
  - 삽입`enQueue` 과   삭제`deQueue`

​    

  

- **주요 연산**
  - ![제목 없음](https://user-images.githubusercontent.com/89068148/155978282-3df4cfd4-2932-46f8-a85c-382e28787b03.png)

​                   

​               

- **종류**
  - **선형 큐**
  
    - ```python
      # 삽입 위치
      rear = rear + 1
      
      # 삭제 위치
      front = front + 1
      ```
  
    - 잘못된 포화 상태 인식 문제
  
      고정된 리스트 크기로 인해, 삽입 및 삭제를 계속 할 경우 앞부분에 활용할 공간이 있음에도
  
      rear = n-1 포화 상태로 인식하게 됨
  
    - 삽입 및 삭제의 처리속도는 빠르지만 메모리 낭비가 심함
  
  ​               
  
  ​              
  
  - **원형 큐**
  
    - 사용하는 리스트의 처음과 마지막 부분을 연결하여 사용
  
    - 특징
  
      ```python
      # 초기 공백 상태
      front = rear = 0
      
      # index 순환
      front 와 rear의 위치가 리스트의 마지막 인덱스인 n-1을 가리킨 후, 
      논리적 순환을 이루어 리스트의 처음 인덱스인 0으로 이동해야 함
      이를 위해 나머지 연산자인 %를 사용
      
      # front 변수
      공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고
      항상 빈자리로 둠
      ```
  
    - 메모리는 절약할 수 있지만(크기를 동적으로 변경), 파이썬 리스트 특성을 사용한 원형 큐의 경우
  
      삽입 및 삭제시 연산 수행에 많은 시간을 소모
  
    - 구현
  
      ```python
      def isEmpty():
          return front == rear
      
      def isFull():
          return (rear+1) % n == front
      
      def enQueue(x):
          global rear
          if not isFull():
              rear = (rear+1) % n
              Q[rear] = x
              
      def deQueue():
          global front
          if not isEmpty():
              front = (front + 1) % n
              return Q.pop(front)
              
      ```
  
      
  
  ​                  
  
  - **연결 큐**
    - 연결리스트 이용
  
  ​          
  
  ​            
  
  - **우선순위 큐**
  
    - 우선순위를 가진 항목들을 저장하는 큐
  
    - 우선순위가 높은 순서대로 먼저 나가게 됨
  
    - 적용 분야 : 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 태스크 스케줄링
  
    - ```python
      heap 나중에 추가 될 내용
      ```