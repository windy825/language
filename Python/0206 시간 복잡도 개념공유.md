### 프로그램과 실행속도

---

프로그램 작성시 시간은 중요합니다.

양질의 시간을 판단하는 기준인 **실행시간(Running time)** 에 연관된 요소로 시간 복잡도와, 

공간 복잡도가 있습니다. 







### 시간 복잡도와 공간 복잡도

최적의 알고리즘은 시간 복잡도와 공간 복잡도로 분석한 결과가 둘 다 어느정도 좋은 것을 뜻합니다.

- 시간 복잡도 : 속도에 관한 분석 결과
- 공간 복잡도 : 메모리 사용향에 대한 분석 결과

즉, 메모리도 적게 쓰고 속도도 최고로 빨라야 최적의 알고리즘 이라고 할 수 있겠습니다.



그러나, 시간이 지날수록 하드웨어 성능의 향상, 부품, 메모리 용량 등 메모리는 외부적 요인에 의해

지속적으로 개선되기 때문에, 시간 복잡도와 공간복잡도를 동시에 사용하여 어느 것이 더 좋다라고

판단하기엔 애매합니다.

따라서 보통은 시간 복잡도를 중요한 요소로 판단하게 됩니다.







### 시간 복잡도 계산과 O(n) (Big-oh 기법)



1. **연산 횟수에 카운트 되는 것들**

   - 변수에 값 할당

   - 함수 호출

   - 산술연산 (더하기, 빼기, 곱하기, 나누기 등)

   - 비교연산 (크다, 작다, 같다, 아니다)

   - 인덱싱

   - 반환 (return)

   - 참조 or 속성 접근

​	만약에 n개의 데이터에서 각각 위의 것들이 3번씩 처리가 된다면, `N x 3` 의 시간복잡도를 가집니다.

​	경우에 따라서 시간복잡도를 구하는 것이 복잡할 수도 있기 때문에, 가장 차수가 높은 것만 남겨서

​	비교하는 방법이 있습니다.

​	(차수가 높은 N이 처리할 데이터가 많을 수록 그 차이가 커지기 때문)

​	`F(x) = n^5 + n^3 + n + 91`

​	위 식을 **O(n)** 으로 표현한다면? (Big-oh기법)   >>>  n^5의 시간 복잡도를 가집니다.

​	해당 표기법은 시간표현식을 단순화한다는 의미 보다는, 정확한 표현식의 의미를 모르더라도 

​	특정 프로그램의  성능은 이정도쯤 되겠구나 하고 판단할 수 있습니다.



2. **O(n) 종류**

   - O(1) : 상수 시간

   ![상수시간](https://user-images.githubusercontent.com/89068148/152670304-7119e6f4-cc92-4f65-8354-d8535115a47c.png)

   - O(*log*n) : 로그시간 or 대수시간
   
   ![로그n](https://user-images.githubusercontent.com/89068148/152670320-81bd60ee-4c60-4deb-8fd9-7d8d02d35243.png)
   
   - O(n) : 선형 시간
   
   ![y=n](https://user-images.githubusercontent.com/89068148/152670328-5ee6d026-89f1-4fc2-9e88-8924a7dddf6a.png)
   
   - O(n*log*n) :  로그선형 시간
   
   ![y=nlogn](https://user-images.githubusercontent.com/89068148/152670338-956cd17a-8054-4956-849a-9fcbd2b1d2e3.png)
   
   - O(n^2) : 제곱 시간
   
   ![y=n^2](https://user-images.githubusercontent.com/89068148/152670346-42944921-621e-4ee2-a274-15693b57d14f.png)
   
   - O(n^3) : 세제곱 시간
   
   ![y=n^3](https://user-images.githubusercontent.com/89068148/152670351-f6e3ad06-9893-4a72-a74c-91240eda5c56.png)
   
   - O(2^n) : 지수 시간



- 전체 샷

![전체](https://user-images.githubusercontent.com/89068148/152670363-5495e8f7-6a8e-4347-ae50-fa0cbc41ae1d.png)

그런데 여기서, 밑 x축은 데이터의 수를 낫타냅니다. 따라서, 데이터 수는 1개부터 유효합니다

(테스트 케이스의 수는 최소 1개 이므로)



![마지막](https://user-images.githubusercontent.com/89068148/152670384-2cfdeb51-f4d4-4282-94aa-e14355089bfd.png)

오른쪽 범위 (데이터 수가 1인 지점부터)



---

*end*



