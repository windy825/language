# 프로그래밍 제약 조건과 요구사항

<br>

#### 어떤 내용이 있나?

- 프로그래밍 언어의 특성
- 프로그램이 동작할 HW와 OS에 관한 지식
- 라이브로리들의 유의 사항들
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드

<br>

#### SW 문제 해결 역량이란 무엇인가?

- 제약 조건과 요구사항을 이해하고 **최선의 방법을 찾아내는 능력**

- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯

  이들을 **연결하여 큰 그림을 만드는 능력**이라 할 수 있다.

- 문제 해결 역량은 **추상적인 기술** 이다.

- 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

<br>

#### 체계적인 접근을 위한 질문들

- 비슷한 유형이 있었나?
- 단순한 방법에서 시작할 수 있나?
- 문제를 단순화 할 수 있나?
- 그림 또는 수식으로 표현 가능한가?
- 문제를 분해 할 수 있나?
- 뒤에서부터 생각해서 문제를 풀 수 있나?
- 특정 형태의 답만을 고려할 수 있나?

<br>

<br>

<br>

# 알고리즘

<br>

#### 효율성

- 공간적 효율성과 시간적 효율성
  - 공간적 효율성 : 연산량 대비 얼마나 적은 메모리 공간을 필요로 하는가
  - 시간적 효율성 : 연산량 대비 얼마나 적은 시간을 필요로 하는가
  - 효율성을 뒤집어 표현하면 복잡도가 된다. 복잡도가 높을수록 효율성은 저하된다.

<br>

#### 시간적 복잡도 분석

- 하드웨어 환경에 따라 처리시간이 달라진다.
  - 부동소수 처리 프로세서 존재 유무, 나눗셈 가속기능 유무, 입출력 장비의 성능, 공유 여부
- 소프트웨어 환경에 따라 처리시간이 달라진다.
  - 프로그램 언어의 종류
  - 운영체제, 컴파일러의 종류
- 환경적 차이로 인해 사실상 정밀한 분석이 어렵다.

<br>

#### 복잡도의 점근적 표기

- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.

  이를 단순한 함수로 표현하기 위해 점근적 표기를 사용한다.







# 비트 연산

<br>

| 연산자 |             기능              |
| :----: | :---------------------------: |
| **&**  |           AND 연산            |
| **\|** |            OR 연산            |
| **^**  | XOR 연산 (같으면 0, 다르면 1) |
| **~**  | 단항 연산자 (피연산자를 반전) |
| **<<** |    비트 열을 왼쪽으로 이동    |
| **>>** |   비트 열을 오른쪽으로 이동   |

<br>

- **1 << n**

  - 2^n 값을 가진다.

  - 원소가 n개 일때 모든 부분집합의 수를 의미한다.

  - Power set (모든 부분 집합)

    공집합과 자기자신을 포함한 모든 부분집합

    각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 된다.

- **i & (1 << j)**

  - 계산 결과는 i의 j 번째 비트가 1인지 아닌지를 의미한다.

<br>

- 비트연산 예제 1

```python
def bit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1 << j) else "0"
    print(output)

# bit_prin(5) >>> 
```

