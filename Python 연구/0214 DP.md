##  DP  *Dynamic Programming (동적 계획법)*

​                    

- 큰 문제를 **작은 문제로 나눠서** 푸는 알고리즘
- **유형**
  - DP : 나눠진 작은 문제들이 중복 가능
  - 분할정복 : 나눠진 작은 문제들이 중복 불가능

​                  

- **DP를 만족하는 두 가지 속성?**

  - Overlapping Subproblem : 겹치는 부분문제 (작은것들이 서로 중복가능해야 함)

    ```python
    # 피보나치 수
    Fn = Fn-1 + Fn-2 ( n >= 2 )
    
    
    # 왜 작은것들이 겹치는 구조일까? 
    # 작은 요소가 한 단계에만 쓰이지 않고, 다른 단계에도 사용 (겹치게 구성)
    Fn    =  Fn-1  +  Fn-2
    Fn-1  =  Fn-2  +  Fn-3
    Fn-2  =  Fn-3  +  Fn-4
    Fn-3  =  Fn-4  +  Fn-5
    ```

    ​           

  - Optimal Substructure : 최적부분구조 (작은것의 해를 통해서 큰것의 해를 구할 수 있다)

    ```python
    # 문제의 크기와 상관없이 어떤 한 문제의 정답은 항상 일정하다.
    
    10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
    9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
    8번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
    7번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
    6번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
    ...
    
    각각의 4번째 피보나치 수는 모두 같다. 
    ```

    따라서, 한번 구한 부분답은 Memoization을 통해 저장해놓고, 필요할때 꺼내 쓰기

    예를 들면 단순히 리스트에 저장하는 것

    ​             

- **DP가 적용된 예시**

  - 피보나치 수

    ```python
    def func(N):
        if N <= 1:
            return N
        
        return func(N-1) + func(N-2) 
    ```

  - memoization 을 추가한다면

    ```python
    memo = [0] * 100     # 100 : 임의 지정
    
    def func(N):
        if N <= 1:
            return N
        else:                       # memo에 저장된 값이라면, 바로 반환
            if memo[N]:
                return memo[N]
        
        memo[N] = func(N-1) + func(N-2)     # memo에 없는 처음보는 값이라면, 구하기
        return memo[N]
    
    
    func(10)     # 처음은 실행시간이 소요되겠지만,
    func(10)     # 두번째부터는 한번 구한 값은 바로 반환 가능
    ```

    ​             

- **구현 방식**

  - Top-down : 재귀 
  - Bottom-up : 반복문 주로 사용 (작은문제들을 해결하면서 점차 큰 문제를 해결)

  - 파이썬의 경우 스택 오버 플로우가 자주 발생하기 때문에 반복문을 주로 쓰자, 

    C 나JAVA는 스택이 넘칠 일이 거의 없기 때문에 재귀도 쓸만하다고 합니다.

    방식 둘의 시간차이는 알수 없음. 

​                   

