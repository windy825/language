### 2차원 배열 갖고 놀기



### 1. 2차원 배열 받기

```python
arr1 = [input() for _ in range(N)]   #N은 받을 2차원 배열의 줄 수
```



### 2. 배열 뒤집기

일반적인 문제에서, 가로줄을 순회하며 검사하고 세로줄을 순회하며 검사할때가 많습니다.



![배열 가로세로순회](https://user-images.githubusercontent.com/89068148/153021619-f3345167-be5b-44e9-a8e8-e162a59adbc5.gif)



그러나, 우리는 세로를 순회하기 위해선 특정 조건이나, 변수등을 지정하는 등 번거러운 처리가 

필요할때가 있습니다.

이럴땐, 세로줄과 가로줄을 서로 바꿔주면 어떨까요?

고려해볼 함수는 `zip()` 입니다.



- **`zip(*iterables)`**

  이 내장함수는 iterable한 자료형을 단일이 아닌 여러개를 받습니다. 

  그 후 받은 iterable 자료형들을 같은 인덱스의 값끼리 묶어서 튜플로 반환 합니다.

  물론 iterable 1개만 들어가도 작동하지만, 우리가 원하는 기능은 아닙니다.

  즉, 단일로 들어갈 순 있지만 쓰진 않습니다.

  

  일단 한번 볼까요? (iterable이 1개만 들어갔을때)

  ```python
  a = [1,2,3,4,5]
  list(zip(  a  ))
  
  >>>
  [(1,), (2,), (3,), (4,), (5,)]
  ```

  iterable 자료형은 모두 가능합니다 (시퀀스이면, iterable)

  ```python
  list(zip(  range(10)  ))
  
  >>>
  [(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)]
  ```

  ```python
  list(zip( 'abcdefghi' ))
  
  >>>
  [('a',), ('b',), ('c',), ('d',), ('e',), ('f',), ('g',), ('h',), ('i',)]
  ```

  ```python
  list(zip( (1,2,3,4,5,6,7) ))
  
  >>>
  [(1,), (2,), (3,), (4,), (5,), (6,), (7,)]
  ```

  

  왜! 대체 왜 1개의 iterable자료만 들어가도 작동할까요??

  같은 인덱스끼리 묶어줄 친구가 없는 데 말이죠

  zip은 내부적으로 `*`을 통해 같은 인덱스끼리 몇개 있는지 확인합니다.

  ```python
  1. 한개의 iterable 자료 투입  list( zip( * iterable ) )
  ['a','b','c','d']
  
  
  2. 내부에서 *을 통해 언패킹
  언패킹 된 상태 : 'a' 'b' 'c' 'd'
  각 값의 인덱스 :  0   1   2   3
  
      
  3. 같은 인덱스가 몇개씩 있는지 확인
  각 값의 인덱스 :  0   1   2   3
  >>>
  0이 1개, 1이 1개, 2가 1개, 3이 1개
  이중 최소값을 기준으로 묶음 처리 (1개가 가장 적습니다.)
  
  
  4. 같은 인덱스를 가진 값 끼리 묶음 처리해서 zip 객체로 저장 (튜플은 값이 1개일때 ,를 붙여줍니다.)
  ('a',) ('b',) ('c',) ('d', )
  
  
  5. 저장된 zip 객체를 list()를 통해 [('a',), ('b',), ('c',), ('d', )] 형태로 표현
  
  
  
  만일 빈 인자를 넣는다면?
  list(zip())
  
  >>>
  []
  ```

  

  원리가 이해 가면, 이제 쉽게 와닿습니다.

  ```python
  a = ['a','b','c','d']
  b = [ 3 , 5 , 7 , 9 ]
  
  list(zip(a,b)) 실행
  
  
  1. 내부에서 *을 통해 언패킹
  언패킹 된 상태 : 'a' 'b' 'c' 'd'       언패킹 된 상태 :  3   5   7   9
  각 값의 인덱스 :  0   1   2   3        각 값의 인덱스 :  0   1   2   3
  
          
  2. 같은 인덱스가 몇개씩 있는지 확인
  각 값의 인덱스 :  0   1   2   3        각 값의 인덱스 :  0   1   2   3
  >>>
  0이 2개, 1이 2개, 2가 2개, 3이 2개
  이중 최소값을 기준으로 묶음 처리 (2개가 가장 적습니다.)
  
  
  4. 같은 인덱스를 가진 값 끼리 튜플묶음 해서 zip 객체로 저장 (튜플은 값이 1개일때 ,를 붙여줍니다.)
  ('a', 3) ('b', 5) ('c', 7) ('d', 9)
  
  
  5. 저장된 zip 객체를 list()를 통해 [('a', 3), ('b', 5), ('c', 7), ('d', 9)] 형태로 표현
  
  ```

  

  

  이번엔 2차원 배열을 뒤집겠습니다.

  ```python
  list( zip(  *배열  ) )  
  ```

  여기서 왜 `*` 언패킹을 붙여 줄까요?? 내부에서 *을 할텐데 말이죠??

  다음과 같은 2차원 배열이 있습니다. (`,`쉽표 임의 생략)

  

  ![제목 없음](https://user-images.githubusercontent.com/89068148/153029569-3ec0c5c6-9e1c-4850-9d25-73eb33f18eb3.png)

  

  우리는 **`*`을 통해 한꺼풀 벗겨준 후** `zip`에 넣어 줍니다

  

  ![제목 없음22](https://user-images.githubusercontent.com/89068148/153030039-cb309a6f-8eea-4cbe-b967-523269464319.png)

  

  **`zip()`함수의 내부 처리 과정에서 `*` 처리**가 됩니다.

  

  ![제목 없음33](https://user-images.githubusercontent.com/89068148/153030281-14dee367-949f-4653-925e-faf3df9b618f.png)

  

  

  여기서 **만약 `*`을 하지 않고 넣는다면? 내부적으로 1번 처리되는게 끝**이겠죠??

  

  ![제목 없음22](https://user-images.githubusercontent.com/89068148/153030758-cc4e1665-25f8-4b2d-a0e4-f9d2a49ed0e7.png)

  

  그럼 위와 같은 최종 모습으로 함수는 1차원 배열이 3개인 상태에서 인덱스를 계산합니다.

  **1차원 배열 자체가 하나의 값**으로 인식됩니다.

  ```python
  1. 내부에서 *을 통해 언패킹
  상  태: ['a','b','c','d']        상  태: [1,2,3,4]        상  태: [6,7,8,9]
  인덱스:         0                인덱스:      0            인덱스:     0
  
          
  2. 같은 인덱스가 몇개씩 있는지 확인
  각 값의 인덱스 :  0           각 값의 인덱스 :  0       각 값의 인덱스 :  0
  
  >>>
  0 이 1개
  이중 최소값을 기준으로 묶음 처리 (1개가 가장 적습니다.)
  ```

  

  다시 돌아가서 `list( zip( * 배열 ) )` 에서, **함수 내부기능인 `*`까지 끝난 상태** 입니다.

  

  ![제목 없음33](https://user-images.githubusercontent.com/89068148/153032124-0771d4ee-c0cb-4f24-9c75-d20523e16880.png)

  

  ```python
  1. 내부에서 *을 통해 언패킹
  상  태: 'a','b','c','d'      상  태: 1 , 2 , 3 , 4      상  태: 6 , 7 , 8 , 9 
  인덱스:  0   1   2   3        인덱스: 0   1   2   3      인덱스: 0   1   2   3 
  
          
  2. 같은 인덱스가 몇개씩 있는지 확인
  
  >>>
  0 이 3개, 1이 3개, 2가 3개, 3이 3개
  이중 최소값을 기준으로 묶음 처리 (3개가 가장 적습니다.)
  ```

  

  **같은 인덱스끼리** 3개씩 **튜플로** 묶습니다.

  

  ![제목 없음44](https://user-images.githubusercontent.com/89068148/153033138-09b1fa32-cc94-42bb-a0ae-2abd304006e5.png)

  

  ![제목 없음55](https://user-images.githubusercontent.com/89068148/153033792-d6831fda-c22a-4e3c-904f-501a622c8536.png)

  `list()` 가 아직 남았죠? 

  ```python
  [ ('a', 1, 6), ( 'b', 2, 7 ), ( 'c', 3, 8 ), ( 'd', 4, 9 ) ]
  ```

  

  여기서 내부의 1차원 배열도 리스트로 씌우고 싶다면 어찌 해야 할까요??

  **`map()` 함수를 이용해서, `zip()` 처리된 튜플들에 `list()` 를 각각 씌워**주면 되겠죠??

  ```python
  list( map( list,zip( *arr ) ) )
  
  >>>
  [ ['a', 1, 6], ['b', 2, 7 ], ['c', 3, 8], ['d', 4, 9] ]
  ```

  `zip(*arr)` 는 `('a', 1, 6), ( 'b', 2, 7 ), ( 'c', 3, 8 ), ( 'd', 4, 9 )` 정보가 

  저장되있습니다. 

  (정확하게는 해당 정보가 저장된 이터레이터 객체입니다. 이터레이터는 해당 원소 값을 

  하나씩 저장하는 것이 아니라  해당 순회 정보를 메모리에 저장시켜놓습니다.

  즉, 해당 원소들을 언제든지 꺼낼 수 있는, 꺼낼 순서가 기록된 큰 통입니다.

  원소 하나씩 모두 저장하지 않기 때문에 메모리를 많이 차지 하지 않습니다. 해당 원소들은 그 값을 꺼낼때, 

  값으로 인식되어 메모리가 쓰입니다.

  설명이 좀 구리죠?? 직접 찾아보시고, 공부해보세요. 다만, 지금 우리가 급하게 배워야 할 부분은 아닙니다.)

  해당 이터레이터에서 **map을 통해, 저장된 정보를 하나씩 꺼내어 list 적용** 합니다.

  

  이제 까먹지 않겠죠?? 

  `list( zip( *arr ) )`

  

  ![배열 뒤집기](https://user-images.githubusercontent.com/89068148/153037113-7c99e3ae-7813-4efd-81b6-8290d67f5d0a.gif)



---

*end*